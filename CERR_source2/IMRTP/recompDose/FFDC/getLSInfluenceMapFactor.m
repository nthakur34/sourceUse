function [inflMap, colXCoord, rowYCoord, colDividerXCoord, rowDividerYCoord, rowLeafPositions] = getLSInfluenceMapFactor(precisionFluenceMap, LS,leak,beamIndex, MLC);
%"getLSInfluenceMap"
%   Gets an image of the influence generated by the beam described in LS.
%   Use getDICOMLeafPositions to generate LS.
%
%JRA&KZ 02/8/05
%
%Usage:
%   function inflMap = getLSInfluenceMap(LS);
%
% Copyright 2010, Joseph O. Deasy, on behalf of the CERR development team.
% 
% This file is part of The Computational Environment for Radiotherapy Research (CERR).
% 
% CERR development has been led by:  Aditya Apte, Divya Khullar, James Alaly, and Joseph O. Deasy.
% 
% CERR has been financially supported by the US National Institutes of Health under multiple grants.
% 
% CERR is distributed under the terms of the Lesser GNU Public License. 
% 
%     This version of CERR is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
% 
% CERR is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
% without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% See the GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with CERR.  If not, see <http://www.gnu.org/licenses/>.

%Maximum precision of leaf position, in mm.
%precision = .1;
% JC, AUG 09, 2006, No Need to use 0.1mm precision. Could go larger.

% JC, Sept 19, 2007
% Add MLC modeling, 
% 1.
% Shift the MLC positions by using the "MLCTABLE.TXT" files provided by
% Varian.
% 2.
% Round leaf tip.
% 3.
% Inter-leaf-leakage.

if (MLC == 1)

% Only implemented for Varian 120 MLC for now.
disp('shift the MLC leaf tip by the amount specificed by Varian, using MLCTABLE.mat file');
try
load('MLCTABLE.mat', 'MLCTABLE');
catch
    disp('No MLCTABLE.mat provided');
    pwd
end


for i = 1: length(LS.xLeafPositions)
    % The units in MLCTABLE is in cm. Change it into mm to be consistent
    % with DICOM leaf positions.
LS.xLeafPositions{i} = interp1(10*MLCTABLE(:,1), 10*MLCTABLE(:,2),LS.xLeafPositions{i}, 'linear', 'extrap');
end

end

precision = precisionFluenceMap;

%Get x max, min and round to precision value.
% xMax = ceil(max(vertcat(LS.xLimits{1}),[],1) / precision) * precision;
% xMin = floor(min(vertcat(LS.xLimits{1}),[],1) / precision) * precision;
% fieldSize.x = max(xMax) - min(xMin);
% fieldLim.x  = [max(xMax) min(xMin)];


xMax = ceil(max(vertcat(LS.xLimits{:}),[],1) / precision) * precision;
xMin = floor(min(vertcat(LS.xLimits{:}),[],1) / precision) * precision;
fieldSize.x = max(xMax) - min(xMin);
fieldLim.x  = [max(xMax) min(xMin)];

yMax = ceil(max(vertcat(LS.yLimits{:}),[],1) / precision) * precision;
yMin = floor(min(vertcat(LS.yLimits{:}),[],1) / precision) * precision;
fieldSize.y = max(yMax) - min(yMin);
fieldLim.y  = [max(yMax) min(yMin)];

yRes = precision;
nyElements = ceil(fieldSize.y/yRes);
xRes = precision;
nxElements = ceil(fieldSize.x/xRes);

inflMap=zeros(nyElements, nxElements);
colDividerXCoord = linspace(fieldLim.x(2), fieldLim.x(1), nxElements+1);
rowDividerYCoord = linspace(fieldLim.y(2), fieldLim.y(1), nyElements+1);

if isfield(LS, 'yLeafPositions')
    rowLeafPositions = round(interp1(rowDividerYCoord, 1:nyElements+1, LS.yLeafPositions,'linear', 'extrap'));
    rowLeafPositions = clip(rowLeafPositions, 1, nyElements+1, 'limits');
    leafBoundariesToKeep = [diff(rowLeafPositions)>0;logical(1)];
    rowLeafPositions = rowLeafPositions(leafBoundariesToKeep);
    leavesToKeep = leafBoundariesToKeep(1:end-1);
else
    %LS.xLeafPositions{1} = [xMin xMax-precision];
    LS.xLeafPositions{1} = [xMin xMax];
    LS.meterSetWeight = {1};
    rowLeafPositions = [1 nyElements+1];
    leavesToKeep = 1;
end

if length(LS.meterSetWeight) == 1
    doses = LS.meterSetWeight{:};
else
    doses = [0 diff([LS.meterSetWeight{:}])];
end

% backupMap = inflMap;
h = waitbar(0,['Generating Fluence Map From MLC Positions For Beam ',num2str(beamIndex)]);

for i=1:length(LS.xLeafPositions)
    %    inflMap = backupMap;
    nLeaves = length(LS.xLeafPositions{i})/2;

    if length(LS.xLimits) > 1
        jpL = LS.xLimits{i}(1);
        jpR = LS.xLimits{i}(2);
    else
        jpL = LS.xLimits{1}(1);
        jpR = LS.xLimits{1}(2);
    end

    lpL = LS.xLeafPositions{i}(1:nLeaves);
    lpR = LS.xLeafPositions{i}(nLeaves+1:end);
    lpLK = lpL(leavesToKeep);
    lpRK = lpR(leavesToKeep);
    lpLCols = interp1(colDividerXCoord, 1:nxElements+1, lpLK, 'linear', 'extrap');
    lpRCols = interp1(colDividerXCoord, 1:nxElements+1, lpRK, 'linear', 'extrap');

    %Column divider positions of jaws.
    jpLCol = interp1(colDividerXCoord, 1:nxElements+1, jpL, 'linear', 'extrap');
    jpRCol = interp1(colDividerXCoord, 1:nxElements+1, jpR, 'linear', 'extrap');

    lpLCols = clip(lpLCols, jpLCol, jpRCol, 'limits');
    lpRCols = clip(lpRCols, jpLCol, jpRCol, 'limits');

    lpLCols = round(lpLCols);
    lpRCols = round(lpRCols);

    %head scatter radiation parametrs for varian
    %! a2 = 0.078;
    %! beta = 1.79;
    %! lambda = 7.69;


    for j=1:length(lpLCols)
        % JC Aug 09 2006, change the data type of i and j into integer, because MATLAB
        % complains about it.
        j = int16(j);
        i = int16(i);
        %HCF from output ratio for MLC fields Zhu, MedPhys
        %! YMLC = rowDividerYCoord(rowLeafPositions(j)) + abs((rowDividerYCoord(rowLeafPositions(j+1)) - rowDividerYCoord(rowLeafPositions(j))))/2;
        %! YMLC = YMLC/10;
        %! sizeLeaf = abs((rowDividerYCoord(rowLeafPositions(j+1)) - rowDividerYCoord(rowLeafPositions(j))));
        %! sizeLeaf = sizeLeaf/10;
        %! HCF_UP = 1 + a2*(erf(2*lpLK(j)*beta/(10*lambda)) +  erf(2*lpRK(j)*beta/(10*lambda)))*(erf(2*(YMLC + sizeLeaf/2)/lambda) - erf(2*(YMLC - sizeLeaf/2)/lambda))/4;
        %! HCF_Down = 1 + a2*(erf(2*jpL/(10*lambda)) +  erf(2*jpR/(10*lambda)))*(erf(2*(YMLC + sizeLeaf/2)/lambda) - erf(2*(YMLC - sizeLeaf/2)/lambda))/4;
        %! HCF = HCF_UP/HCF_Down;
        %! inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) + HCF*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) + doses(i);
%        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, jpLCol:lpLCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, jpLCol:lpLCols(j)-1) + leak*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(jpLCol):int16(lpLCols(j)-1)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(jpLCol):lpLCols(j)-1) + leak*doses(i);
        %        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):jpRCol-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):jpRCol-1) + leak*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpRCols(j)):int16(jpRCol-1)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpRCols(j)):int16(jpRCol-1)) + leak*doses(i);

if (MLC == 1)        
%!      Add leak of the MLC round leaf end of the LEFT leaf; for the grid
%of 1mm, 
        % rTCol = max(1,int16(lpLCols(j)-tongueCols));
       if (lpLCols(j)-4 > 0 & lpLCols(j) < nxElements)
           % Can not assume 100% transmission underneath where the two leaf tips touch. 
           % l = repmat([0.02 0.024 0.043 0.095 0.5]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1); 
            l = repmat([0.02 0.024 0.043 0.095 0.15]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1); 
            inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-4):lpLCols(j)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-4):lpLCols(j)) + l*doses(i);
        end
%!      Add leak of the MLC round leaf end of the RIGHT leaf
        if (lpRCols(j) > 0 & lpRCols(j)+4 < nxElements)   % maximum size of inflMap
            % To include the transmission of the leaf tip: lpRCols(j),
            % otherwise, there will be a dip where two leaf abut.
            % l = repmat([0.5 0.095 0.043 0.024 0.02]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1); 
            l = repmat([0.15 0.095 0.043 0.024 0.02]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1); 
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+4) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+4) + l*doses(i);
        end
        
        %! Need to add the tongue-and-groove effect, i.e. the inter-leaf
        %dose leakage, dose spikes.
        %! Figure out the leaf edges.
        %! Need to know where the extra leakage starts and end, i.e. the
        %distance of groove. 
        % ---------------------------------------) 
        %             |-----------------------|    )
        %                                            )         
        %                                              )
        %                                               )
        %                                            )         
        %             |-----------------------|    )
        % ---------------------------------------) 
        tongueLeak = 0.01;      % 0.01 = 5! extra leak beneath tongue and groove
        tongueToLeafTip = 5;    %mm
        tongueWidth = 1;        %mm
        % Need to figure out the "column #" where the groove starts and
        % ends.
        
        % Increase the transmission of the fluence map over the groove
        % region.
        tongueRows = int16(tongueWidth/yRes);
        tongueCols = int16(tongueToLeafTip/xRes);
        
        % Add the tongue leak on the lower and higher edges of the leaf.
        % Left Leaf
        rTRow = min(rowLeafPositions(j)-1+tongueRows, nyElements);
        % The tongue-and-groove runs throug the whole leaf length
        rTCol = max(1,int16(lpLCols(j)-tongueCols));
        
        inflMap(rowLeafPositions(j):rTRow, 1:rTCol) = ...
        inflMap(rowLeafPositions(j):rTRow, 1:rTCol) + tongueLeak*doses(i);
        
    %  One the higher portion of the leaf
    %  Temporary account only one side of the inter-leaf-leak
    %!   rTRow = max(1, rowLeafPositions(j+1)-1-tongueRows);
    %!   inflMap(rowLeafPositions(j+1)-1:rTRow, 1:rTCol) = ...
    %!   inflMap(rowLeafPositions(j+1)-1:rTRow, 1:rTCol) + tongueLeak*doses(i);
        
% %         % Right Leaf
        rTRow = min(rowLeafPositions(j)-1+tongueRows, nyElements);
        rTCol = min(lpRCols(j)-1+tongueCols, nxElements);

        inflMap(rowLeafPositions(j):rTRow, rTCol:nxElements) = ...
        inflMap(rowLeafPositions(j):rTRow, rTCol:nxElements) + tongueLeak*doses(i);

    %  One the higher portion of the leaf
    %!   rTRow = max(1, rowLeafPositions(j+1)-1-tongueRows);
    %!   inflMap(rowLeafPositions(j+1)-1:rTRow, rTCol:nxElements) = ...
    %!   inflMap(rowLeafPositions(j+1)-1:rTRow, rTCol:nxElements) + tongueLeak*doses(i);

        % Also need to add the tongue leak for the closed leaf pair.
        % .....
end

    end % if (MLC ==1)    

    waitbar(i/length(LS.xLeafPositions));

%        frame = inflMap;
%        imagesc(inflMap);
%        mi(:,:,i) = inflMap;
%        inflMap(inflMap == 0) = 1;
%        inflMap(inflMap ~= 0) = 2;
%        colormap([0 0 0; 1 1 1]);
%        %mi(:,:,i) = inflMap;
%        %mi(i) = im2frame(inflMap, [0 0 0; 1 1 1]);
%        drawnow;
%        pause(.006);
end
close(h);
colXCoord = colDividerXCoord(1:end-1) + precision/2;
rowYCoord = rowDividerYCoord(1:end-1) + precision/2;