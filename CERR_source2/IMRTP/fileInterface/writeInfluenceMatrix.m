function flag = writeInfluenceMatrix(IM,structNum,outFile)%"writeInfluenceMatrix"%   Write influence matrix out in 'Eva Lee' format.%   IM is the intensity modulated data structure.%   structNum is the structure number to be written out.%   outFile is the output file.%   flag returns 'error' or 'no error'.%%   Format is:%       <structName> <numVoxels in Struct>%       ##Slice l := <numVox in struct on slice l>;%       ##Slice m := <numVox in struct on slice m>;%           .%           .%           .%       ##Slice n := <numVox in struct on slice n>;%       ##nBeams := <numBeams in influence matrix>;%   Now for each voxel with nonzero dose in the influence matrix, print%   x,y,z coordinate and list of beams and dose from each beam to this voxel.%       (x, y, z)%        <beamNum>  <dose from beamNum to this voxel>   <beamNum> <dose from beamNum to this voxel>   <beamNum> <dose from beamNum to this voxel>%        <beamNum> <dose from beamNum to this voxel>    ;%           .%           .%           .%       (x, y, z)%       <beamNum>  <dose from beamNum to this voxel>    ;%       END%%   JOD, 16 Nov 03.%   JRA & CZ, 6 Jan 03 -- Optimized for faster operation.%   JRA      11 Mar 04 -- Changed for new IndV system. Now outputs total%                         voxels with dose in structure, total voxels with%                        dose on each slice.%   JRA      22 Mar 04 -- block processing changed.  %%Usage:%   function flag = writeInfluenceMatrix(IM,structNum,outFile)   %% Copyright 2010, Joseph O. Deasy, on behalf of the CERR development team.% % This file is part of The Computational Environment for Radiotherapy Research (CERR).% % CERR development has been led by:  Aditya Apte, Divya Khullar, James Alaly, and Joseph O. Deasy.% % CERR has been financially supported by the US National Institutes of Health under multiple grants.% % CERR is distributed under the terms of the Lesser GNU Public License. % %     This version of CERR is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.% % CERR is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;% without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.% See the GNU General Public License for more details.% % You should have received a copy of the GNU General Public License% along with CERR.  If not, see <http://www.gnu.org/licenses/>.global planC%Auto blocksize: max 1 million elements at a time.blockSize = 'auto';%Uncomment this line and modify to manually set the blocksize.%blockSize = 2000;try    if nargin < 3   %default        outFile = 'c:\tmp\default.txt'    else        outFile    end           fid = fopen(outFile,'wt');        %Write the structure name:    str = planC{planC{end}.structures}(structNum).structureName;    fprintf(fid,'%s',[str ' ']);        sampleRate = IM.beamlets(structNum,1).sampleRate;        %Get interpolation coords.    maskSample3D = getDown3Mask(repmat(logical(1), getUniformizedSize(planC)), sampleRate, 1);             maskStruct3D = getUniformStr(structNum);    [rInterpV, cInterpV, sInterpV] = find3d(maskStruct3D & maskSample3D);        %Write the number of voxels in (downsampled) structure.    numStrVoxels = length(sInterpV);    fprintf(fid,'%s\n',num2str(numStrVoxels));    sliceNums = unique(sInterpV);    %Write the list of slices where structure appears & nVox on each.    for i = 1 : length(sliceNums)        k = sliceNums(i);        %get number of nonzero voxels in that slice:        n = nnz(sInterpV == k);        str = ['##Slice ' num2str(k) ' := ' num2str(n) ';'];        fprintf(fid,'%s\n',str);    end    clear rInterpV cInterpV sInterpV maskSample3D maskStruct3D;    %Rows of inflM are voxels, columns are PBs.    disp('Constructing influence matrix...')    [inflM] = getGlobalInfluenceM(IM, structNum);    disp('Done.')    %Find indices of voxels with nonzero dose.    indexV = find(any(inflM,2));    %Get x,y,z coordinates of voxels with dose.    flag = 'uniform';        s = getUniformizedSize(planC);    [rowV, colV, sliceV] = ind2sub(s, indexV);    [xV,yV,zV] = mtoxyz(rowV,colV,sliceV,planC,flag,s);                            %Write number of beamlets.    numBs = size(inflM,2);    str = ['##nBeams := ' num2str(numBs) ';'];    fprintf(fid,'%s',str);        numVoxels = length(indexV);    disp([num2str(numBs) ' pencil beams, ' num2str(prod(s)) ' total voxels in plan, ' num2str(numVoxels) ' voxels with nonzero dose.'])    %Multiply dose by this scale to get absolute dose.    scale = IM.params.writeScale;             %Dynamic blockSize mode: allows max of 1 million elements per block.    %In the unlikely case that there are > 1 million beam elements, use 1.    if blockSize == 'auto'        blockSize = max(round(1000000 / numBs) , 1);    else        blockSize;    end       disp(['Block processing for speed, blockSize = ' num2str(blockSize) '.']);        %Write contributing dose from individual beamlets for each voxel that    %gets nonzero dose.  Use block processing for speed.    for i=1:numVoxels        %Get a new influence matrix block if needed.        if mod(i,blockSize) == 1;            range = i:min(i+blockSize, numVoxels);            inflBlock = full(inflM(indexV(range),:));            counter = 1;        end                %Get x,y,z of this voxel.        x = xV(i); y = yV(i); z = zV(i);        fprintf(fid,'\n');        fprintf(fid, '(%g, %g, %g)', [x y z]);          dose = inflBlock(counter, :);%        dose = inflM(indexV(i), :);        beamNum = find(dose);        vector = 1:2*length(beamNum); %must interleave beamNums and dose.        vector(1:2:end) = beamNum;        vector(2:2:end) = dose(beamNum)*scale;        fprintf(fid, '\n%1.0f  %2.7f    %1.0f  %2.7f    %1.0f  %2.7f    %1.0f  %2.7f    %1.0f  %2.7f    ', vector);                fprintf(fid, '%s', ';');  % end of voxel delimiter        counter = counter + 1;        if rem(i, 10000) == 0            disp(['Processed ' num2str(i) '/' num2str(numVoxels) ' voxels for this structure.'])        end    end        disp(['Processed ' num2str(i) '/' num2str(numVoxels) ' voxels for this structure.']);        %write END    fprintf(fid,'\n');  %    fprintf(fid,'%s\n','END');  %        fclose(fid)        flag = 'no error';   catch    warning(['Error in writeInfluenceMatrix: ' lasterr]);    flag = 'error';    end